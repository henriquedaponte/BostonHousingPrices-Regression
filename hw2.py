import numpy as np
import pandas as pd
import cvxpy as cp

# ====================== Utility Functions ======================

def meanSquaredError(predicted, actual):
    '''
    Calculate the mean squared error (MSE) between predicted and actual values.
    
    Parameters:
    - predicted (numpy array): The array of predicted values generated by the model.
    - actual (numpy array): The array of actual or true values.
    
    Returns:
    - int: The mean squared error, rounded to the nearest whole number, between the predicted and actual values.
    
    Notes:
    The mean squared error is computed as the average of the squared differences between predicted and actual values.
    '''
    
    r = actual - predicted # Residuals
    return round(np.sum(r**2)/len(predicted))

def preprocessData(filename, trainDataPct):
    '''
    Preprocesses the data by loading it and dividing it into training and test sets.
    
    Parameters:
    - filename (str): Path to the input data file.
    - trainDataPct (float): Percentage of data to be used for training (e.g., 0.7 for 70%).
    
    Returns:
    - tuple: 
        - X_train (numpy array): Training data attributes.
        - Y_train (numpy array): Training data target values.
        - X_test (numpy array): Test data attributes.
        - Y_test (numpy array): Test data target values.
    '''
     
    data = pd.read_csv(filename, delimiter='\t')

    # Using trainDataPct% of the data for training
    trainDataSize = int(trainDataPct * data.shape[0])
    trainData = data.iloc[:trainDataSize, :]
    X_train = trainData.iloc[:, :-1].values
    Y_train = (trainData.iloc[:, -1].values).reshape(-1, 1)

    # Using testDataPct% of the data for testing 
    testData = data.iloc[trainDataSize:, :]
    X_test = testData.iloc[:, :-1].values
    Y_test = (testData.iloc[:, -1].values).reshape(-1, 1)

    return X_train, Y_train, X_test, Y_test
    
def trainModel(X_train, Y_train):
    ''''
    Trains a linear regression model using CVX optimization.
    
    Parameters:
    - X_train (numpy array): Training data attributes.
    - Y_train (numpy array): Training data target values.
    
    Returns:
    - tuple:
        - Ytrain_pred (numpy array): Predicted values for the training data.
        - beta (numpy array): Learned coefficients for the attributes.
        - alpha (float): Learned intercept term.
    '''

    # Initilizing decision variables
    alpha = cp.Variable()
    beta = cp.Variable((X_train.shape[1], 1))

    # Defining function for our predictions
    Ytrain_pred = alpha + X_train @ beta

    # Defining objective function
    objective = cp.Minimize(cp.sum_squares(Ytrain_pred - Y_train))

    # Formulating problem
    problem = cp.Problem(objective)

    # solving the problem
    problem.solve()

    return Ytrain_pred.value, beta.value, alpha.value


# ====================== Data Preprocessing =====================

X_train1, Y_train1, X_test1, Y_test1 = preprocessData('housing.txt', 0.3) # Training with 30% of data
X_train2, Y_train2, X_test2, Y_test2 = preprocessData('housing.txt', 0.6) # Training with 60% of data


# ====================== Training the model ======================

Ytrain_pred1, beta1, alpha1 = trainModel(X_train1, Y_train1) # 30% training data
Ytrain_pred2, beta2, alpha2 = trainModel(X_train2, Y_train2) # 60% training data


# ====================== Testing the model ======================

Y_pred1 =  alpha1 + X_test1 @ beta1 # 30% training data
Y_pred2 =  alpha2 + X_test2 @ beta2 # 60% training data


# ====================== Printing Results ======================

# 30% training data
print('Mean squared error for training data (30%): ', meanSquaredError(Ytrain_pred1, Y_train1))
print('Mean squared error for testing data (30%): ', meanSquaredError(Y_pred1, Y_test1))

print('\n') # Creating separation for better readability

# 60% training data
print('Mean squared error for training data (60%): ', meanSquaredError(Ytrain_pred2, Y_train2))
print('Mean squared error for testing data (60%): ', meanSquaredError(Y_pred2, Y_test2))